#include <spawn.h>
#include <wait.h>
#include <unistd.h>

#include <iostream>
#include <vector>
#include <cstring>
#include <unordered_map>
#include <fstream>
#include <mutex>

#include "../include/Response.h"
#include "../include/parser.h"
#include "../include/file_utils.h"
#include "../include/Log.h"
#include "../include/cookieFile.h"
#include "../include/cookiesResponse.h"

// array of environ variables for posix_spawn call
extern char **environ;

static std::string checkRegistredUser(std::string userId, std::string uri, std::string serverRoot, std::vector<std::string> &reqParams);

/**
 * @desc parses parameters after '?' from url to the vector of strings
 * @params uriStr - string that stores URL with parameters
 * @return vector of strings with parsed params
*/
static std::vector<std::string> parseUrlParams(std::string uri) {
    std::vector<std::string> reqParams;
    long unsigned paramStartIndx = uri.find_first_of('?');

    while (paramStartIndx != std::string::npos) {
        // find starting index of the next parameter
        long unsigned paramNextIndx = uri.find_first_of('&', paramStartIndx + 1);
        
        // add to vector substring between start of prev and start of next parameter
        reqParams.push_back(uri.substr(paramStartIndx + 1, paramNextIndx - paramStartIndx - 1));
        // move forward
        paramStartIndx = paramNextIndx;
    }
    return reqParams;
}

/**
 * @desc creates array of cmd parameters for php interpreter
 * @params reqParams - vector of string that stores 
 * request parameters, pageFileName - name of .php file
 * for interpreter 
 * @return DINAMICALLY allocated array of c-strings
*/
static char **createCmdArgs(std::vector<std::string> reqParams, std::string pageFileName) {
    // URL params amount + 3("-f" flag + fileName + nullptr)
    char **argvForPhp = new char*[reqParams.size() + 3];
    // php interpreter requires full path to file
    char *cwd = getcwd(NULL, 0);
    std::string pathToPageFile = cwd;

    argvForPhp[0] = strdup("-f");
    argvForPhp[1] = strdup((pathToPageFile + "/" + pageFileName).c_str());
    // copy URL params to the array of cmd args
    for(long unsigned i = 2; i <= reqParams.size() + 1; i++)
        argvForPhp[i] = strdup(reqParams[i - 2].c_str());
    // add anding nullptr
    argvForPhp[reqParams.size() + 2] = nullptr;

    free(cwd);
    return argvForPhp;
}

/**
 * @desc calls php interpreter using posix_spawn to
 * generate html with parameters (user name, etc.)
 * and html reads it's output from the pipe
 * @params bodyLen - unsinged var to store the length
 * of the html-body generated by php, body -
 * pointer to c-string, where body should be placed,
 * reqParams - vector of strings with parameters from URL,
 * pageFileName - string with the name of .php file
 * @return 0 in case of success, -1 otherwise
*/
static int generateHtmlResponse(size_t &bodyLen,  char **body, std::vector<std::string> reqParams, std::string pageFileName) {
    pid_t pid;
    posix_spawn_file_actions_t pipeAction;
    int phpPipeFds[2];
    char phpResponse[Response::bufferLen] = { 0 };// we should check file size
    int res = 0;

    // create command line arguments for child proc
    char **argvForPhp = createCmdArgs(reqParams, pageFileName);
    
    // create pipe and pass writing end of the pipe to future child proc
    pipe(phpPipeFds);
    posix_spawn_file_actions_init(&pipeAction);
    posix_spawn_file_actions_adddup2(&pipeAction, phpPipeFds[1], 1);

    // create child proc
    int status = posix_spawn(&pid, Response::phpInterpreter, &pipeAction, nullptr, argvForPhp, environ);
    if (status == 0) {
        // process created successfully!
        if (waitpid(pid, &status, 0) != -1)
            Log::writeLog(Log::Level::DEBUG,"Child exited with status %i\n", status);
        else
            Log::writeLog(Log::Level::DEBUG, "waitpid: %s\n", strerror(errno));
        memset(phpResponse, '\0', Response::bufferLen);
        // if proc creeted successfully -> read from the reading end of pipe
        int numBytes = read(phpPipeFds[0], &phpResponse, Response::bufferLen);

        if(numBytes == 0)
            res = -1;
        else {
            // skip php-generated header and copy only html
            char *bodyStart = strstr(phpResponse, "<!DOCTYPE");
            // update length of the body (without header)
            bodyLen = strlen(bodyStart);
            *body = new char[bodyLen];
            strncpy(*body, bodyStart, bodyLen);
        }
    } 
    else {
        // error creating process 
        Log::writeLog(Log::Level::DEBUG, "posix_spawn: %s\n", strerror(status));
        res = -1;
    }

    // free used memory
    for(int i = 0; argvForPhp[i] != nullptr; i++)
        free(argvForPhp[i]);
    delete[] argvForPhp;
    close(phpPipeFds[0]);
    close(phpPipeFds[1]);
    posix_spawn_file_actions_destroy(&pipeAction);

    return res;
}

/**
 * @desc very basic uniq ID of 8 digits generator 
 * @params cookFileMap map of strings that stores
 * id-s from file
 * @return integer id of 8 digits
*/
static int generateUniqId() {
    std::string curUser;
    int newUserId = 0;
    
    do {
        newUserId = 10000000 + rand() % 9999999;

        curUser = cookieFile::findNameByID(std::to_string(newUserId));
    } while (curUser.length() > 0);

    return newUserId;    
}

/**
 * @desc creates response body when uri==root folde
 * @params bodyLen - unsinged var to store the length
 * of the html-body generated by php, body -
 * pointer to c-string, where body should be placed,
 * req - struct that stores parsed request, 
 * serverRoot - name of server root folder
 * @return 0 in case of success, -1 otherwise
*/
int createRootResponseBody(size_t &bodyLen,  char **body, struct s_request *req, std::string serverRoot) {
    std::vector<std::string> reqParams;
    std::ifstream cookFileStream;
    int returnCode = 0;

    // check if cookies present among headers
    const char *userId = find_in_list("Cookie", nullptr, req->head);
    if(!userId) {
        // if no cookies: generate uniq ID

        int newUserId = generateUniqId();
        
        // add generated id to the map
        cookieFile::addID(std::to_string(newUserId));

        // add "Set-Cookie: id=..." header (it will be sent to user)
        std::string cookieValue = "id=" + std::to_string(newUserId);
        push_back(&req->head, "Set-Cookie", cookieValue.c_str());
        // send a form to a user to find out his/her name
        returnCode = generateHtmlResponse(bodyLen, body, reqParams, serverRoot + Response::regFormPage);
    }
    else {
        // if cookies present: get user ID and search for that id in the file

        std::string pageForUser = checkRegistredUser(userId, req->uri, serverRoot, reqParams);
        returnCode = generateHtmlResponse(bodyLen, body, reqParams, pageForUser);
    }

    return returnCode;
}

/**
 * @desc returns name of the page, that should be generated for a user
 * (depending on wether he is registred or not)
 * @params userId - string with user id from cookie ("id=[8 digits]")
 * serverRoot - string with server root folder, reqParams - vector
 * that stores all the parameters from request (those after '?')
 * cookFileMap - map with user id-s and corresponding names (from file)
 * @return std::string with page name
*/
static std::string checkRegistredUser(std::string userId, std::string uri, std::string serverRoot, std::vector<std::string> &reqParams) {
    std::string userIdValue = userId.substr(userId.find_first_of('=') + 1);
    
    // check if URL parameters present
    if(uri.find_first_of('?') != std::string::npos) {
        // if yes: add user name to user ID in the map

        std::string userName;
        reqParams = parseUrlParams(uri);

        // extract user name from url params
        for(unsigned i = 0; i < reqParams.size(); i++) {
            if(reqParams[i].find("UserName") != std::string::npos) {
                userName = reqParams[i].substr(reqParams[i].find_first_of('=') + 1);
                break;
            }
        }
        // add user name to map
        cookieFile::updateName(userIdValue, userName);
        // return page with user name and greetings
        return serverRoot + Response::greetingPage;
    }
    else {
        // if no url params: search for name of current user in map

        std::string curUserName = cookieFile::findNameByID(userIdValue);

        if(curUserName.length() > 0) {
            // save name in proper format for php interpreter
            reqParams.push_back("UserName=" + curUserName);
            reqParams.push_back("submit=Send");
            // if name found -> send greetings to user
            return serverRoot + Response::greetingPage;
        }
        else
            // if name not found -> sent form to find out it
            return serverRoot + Response::regFormPage;
    }
}
